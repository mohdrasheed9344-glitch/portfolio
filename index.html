<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Photography Universe | Capture</title>
    
    <style>
        /*
        * REMOVE MOBILE WARNING OVERLAY
        * This CSS block ensures the mobile warning is hidden,
        * allowing the Three.js canvas to be visible on small screens.
        */
        .mobile-warning {
            display: none !important; /* Forces the warning to be hidden */
        }

        /* * Basic CSS for required elements (You should move this to style.css)
        */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #ff0000;
            font-family: monospace;
        }

        #canvas {
            display: block;
        }

        .loader-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 0.5s ease;
        }

        .loader-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .progress-bar {
            width: 200px;
            height: 4px;
            border: 1px solid #ff0000;
            margin-top: 10px;
        }

        .progress-fill {
            height: 100%;
            background-color: #ff0000;
            width: 0;
            transition: width 0.1s;
        }

        /* UI elements visibility for mobile/desktop */
        .ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the canvas */
            z-index: 10;
        }

        /* Hide desktop-specific elements on mobile */
        @media (max-width: 768px) {
            .fps-counter, .controls, .cursor, .cursor-follower, .info-card {
                display: none !important;
            }
            .main-title {
                text-align: center;
                margin-top: 20px;
            }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/DeviceOrientationControls.js"></script>
</head>
<body>
    <div class="cursor"></div>
    <div class="cursor-follower"></div>

    <div class="loader-container" id="loader">
        <div class="loader-text">INITIALIZING</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="ui-container">
        <div class="nav-menu">
            <div class="menu-btn" id="menuBtn">
                <div class="menu-line"></div>
                <div class="menu-line"></div>
                <div class="menu-line"></div>
            </div>
            <div class="dropdown-content">
                <a href="index.html">3D Universe</a>
                <a href="gallery.html">Gallery</a>
                <a href="profile.html">Profile</a>
            </div>
        </div>

        <div class="fps-counter" id="fps">FPS: 60</div>

        <div class="main-title">
            <h1>Razz</h1>
            <p class="subtitle">3D Photography Experience</p>
        </div>

        <div class="info-card" id="infoCard">
            <h2>Virtual Studio</h2>
            <p>Welcome to an immersive 3D photography experience. Navigate through our virtual space and interact with floating cameras, dynamic lighting, and particle systems.</p>
            <div class="tech-tags">
                <span class="tech-tag">Three.js</span>
                <span class="tech-tag">WebGL</span>
                <span class="tech-tag">3D Graphics</span>
                <span class="tech-tag">Real-time</span>
            </div>
        </div>

        <div class="controls">
            <h3>Controls</h3>
            <div class="control-item"><span class="control-key">MOUSE</span> Look Around</div>
            <div class="control-item"><span class="control-key">SCROLL</span> Zoom In/Out</div>
            <div class="control-item"><span class="control-key">CLICK</span> Interact (Explode Camera)</div>
            <div class="control-item"><span class="control-key">SPACE</span> Reset View</div>
        </div>
    </div>

    <div class="mobile-warning">
        <h2>Desktop Experience Required</h2>
        <p>This 3D experience is optimized for desktop browsers. Please visit on a computer for the full interactive experience.</p>
    </div>

    <script>
        // --- Three.js Logic ---
        let scene, camera, renderer;
        let cameras = [];
        let particles;
        let mouseX = 0, mouseY = 0;
        let targetX = 0, targetY = 0;
        let frame = 0;
        let clock = new THREE.Clock();
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let INTERSECTED;
        let controls; // For mobile/orientation controls

        // Loading Progress
        const progressBar = document.getElementById('progress');
        const loader = document.getElementById('loader');
        
        // Mobile detection flag
        const isMobile = window.innerWidth <= 768;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;
            camera.position.y = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Use a lower pixel ratio on mobile for better frame rates
            renderer.setPixelRatio(isMobile ? 1 : window.devicePixelRatio); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting (Slightly reduced intensity on mobile for performance)
            const ambientLight = new THREE.AmbientLight(0xff0000, isMobile ? 0.1 : 0.2);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xff0000, isMobile ? 1 : 2, 50);
            pointLight1.position.set(20, 20, 20);
            pointLight1.castShadow = true;
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0xffffff, isMobile ? 0.5 : 1, 50);
            pointLight2.position.set(-20, 20, -20);
            scene.add(pointLight2);

            // Create 3D Cameras (Fewer on mobile)
            createCameras(isMobile ? 3 : 5); 

            // Create Particle System (Fewer particles on mobile)
            createParticles(isMobile ? 1000 : 2000);

            // Create Environment
            createEnvironment();

            // Create Grid
            createGrid();

            // Setup Controls
            if (isMobile) {
                // Use Device Orientation Controls for mobile rotation
                controls = new THREE.DeviceOrientationControls(camera);
                document.addEventListener('touchstart', onTouchStart, false);
                document.addEventListener('touchmove', onTouchMove, false);
            } else {
                // Use standard mouse controls for desktop
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('wheel', onWheel);
            }
            
            // Shared Event Listeners
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);

            // Start animation
            simulateLoading();
        }

        // --- Helper functions (Updated for mobile performance) ---

        function createCameras(count) {
            const cameraGeometry = new THREE.Group();
            
            // ... (rest of createCameras function remains the same, but the loop count is now dynamic)
            // Camera body
            const bodyGeometry = new THREE.BoxGeometry(4, 3, 3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a1a1a,
                emissive: 0xff0000,
                emissiveIntensity: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            cameraGeometry.add(body);

            // Lens
            const lensGeometry = new THREE.CylinderGeometry(1.5, 1.2, 2, 32);
            const lensMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x000000,
                emissive: 0xff0000,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            const lens = new THREE.Mesh(lensGeometry, lensMaterial);
            lens.rotation.z = Math.PI / 2;
            lens.position.z = 2;
            cameraGeometry.add(lens);

            // Inner lens
            const innerLensGeometry = new THREE.CircleGeometry(1, 32);
            const innerLensMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                opacity: 0.5,
                transparent: true
            });
            const innerLens = new THREE.Mesh(innerLensGeometry, innerLensMaterial);
            innerLens.position.z = 3;
            cameraGeometry.add(innerLens);

            // Flash
            const flashGeometry = new THREE.BoxGeometry(1, 0.8, 0.5);
            const flashMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: 0xffffff,
                emissiveIntensity: 0.3
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.set(1.8, 1.8, 0);
            cameraGeometry.add(flash);
            
            // Create multiple cameras
            for (let i = 0; i < count; i++) {
                const cam = cameraGeometry.clone();
                cam.position.set(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 20 + 10,
                    (Math.random() - 0.5) * 40
                );
                cam.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                cam.userData = {
                    floatSpeed: Math.random() * 0.5 + 0.5,
                    rotationSpeed: Math.random() * 0.01 + 0.005,
                    originalY: cam.position.y
                };
                cameras.push(cam);
                scene.add(cam);
            }
        }

        function createParticles(count) {
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = count;
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = (Math.random() - 0.5) * 100;
                positions[i + 2] = (Math.random() - 0.5) * 100;

                const isRed = Math.random() > 0.5;
                colors[i] = isRed ? 1 : 0.2;
                colors[i + 1] = 0;
                colors[i + 2] = 0;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }
        
        function createEnvironment() {
            // Floating geometric shapes
            const shapes = [];
            
            // Octahedron
            const octGeometry = new THREE.OctahedronGeometry(3, 0);
            const octMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const octahedron = new THREE.Mesh(octGeometry, octMaterial);
            octahedron.position.set(20, 10, -20);
            scene.add(octahedron);
            shapes.push(octahedron);

            // Torus
            const torusGeometry = new THREE.TorusGeometry(5, 1, 16, 100);
            const torusMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: 0xff0000,
                emissiveIntensity: 0.1,
                shininess: 100
            });
            const torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.position.set(-20, 5, 15);
            scene.add(torus);
            shapes.push(torus);

            // Icosahedron
            const icoGeometry = new THREE.IcosahedronGeometry(2, 0);
            const icoMaterial = new THREE.MeshPhongMaterial({
                color: 0x1a1a1a,
                emissive: 0xff0000,
                emissiveIntensity: 0.2
            });
            const icosahedron = new THREE.Mesh(icoGeometry, icoMaterial);
            icosahedron.position.set(15, -5, 10);
            scene.add(icosahedron);
            shapes.push(icosahedron);

            // Store shapes for animation
            window.envShapes = shapes;
        }

        function createGrid() {
            const gridHelper = new THREE.GridHelper(100, 50, 0xff0000, 0x220000);
            gridHelper.position.y = -10;
            scene.add(gridHelper);
        }

        function createExplosion(position) {
            const particleCount = 30;
            const explosionGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = position.x + (Math.random() - 0.5) * 2;
                positions[i + 1] = position.y + (Math.random() - 0.5) * 2;
                positions[i + 2] = position.z + (Math.random() - 0.5) * 2;
            }
            
            explosionGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const explosionMaterial = new THREE.PointsMaterial({
                color: 0xff0000,
                size: 0.5,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const explosion = new THREE.Points(explosionGeometry, explosionMaterial);
            scene.add(explosion);
            
            // Animate explosion
            let opacity = 1;
            const animateExplosion = () => {
                opacity -= 0.02;
                explosionMaterial.opacity = opacity;
                
                const positions = explosion.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += (Math.random() - 0.5) * 0.5 * opacity;
                    positions[i + 1] += (Math.random() - 0.5) * 0.5 * opacity;
                    positions[i + 2] += (Math.random() - 0.5) * 0.5 * opacity;
                }
                explosion.geometry.attributes.position.needsUpdate = true;
                
                if (opacity > 0) {
                    requestAnimationFrame(animateExplosion);
                } else {
                    explosion.geometry.dispose();
                    explosion.material.dispose();
                    scene.remove(explosion);
                }
            };
            animateExplosion();
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            frame++;
            const delta = clock.getDelta();

            // Update FPS (Desktop only UI element)
            if (!isMobile && frame % 30 === 0) {
                const fpsElement = document.getElementById('fps');
                if (fpsElement) {
                    const fps = Math.round(1 / delta);
                    fpsElement.textContent = `FPS: ${fps}`;
                }
            }

            if (isMobile) {
                // Mobile: Use device orientation controls
                controls.update();
            } else {
                // Desktop: Smooth camera movement based on mouse position
                targetX = mouseX * 0.001;
                targetY = mouseY * 0.001;
                
                camera.rotation.y += (targetX - camera.rotation.y) * 0.05;
                camera.rotation.x += (targetY - camera.rotation.x) * 0.05;

                // Raycasting for hover effect
                raycasterUpdate();
            }


            // Animate cameras
            cameras.forEach((cam) => {
                cam.rotation.x += cam.userData.rotationSpeed;
                cam.rotation.y += cam.userData.rotationSpeed * 1.3;
                cam.position.y = cam.userData.originalY + Math.sin(frame * 0.01 * cam.userData.floatSpeed) * 2;
            });

            // Animate particles
            if (particles) {
                particles.rotation.x += 0.0001;
                particles.rotation.y += 0.0002;
            }

            // Animate environment shapes
            if (window.envShapes) {
                window.envShapes.forEach((shape, i) => {
                    shape.rotation.x += 0.01 * (i + 1) * 0.3;
                    shape.rotation.y += 0.01 * (i + 1) * 0.5;
                });
            }

            renderer.render(scene, camera);
        }

        // --- Raycasting (Desktop Only) ---
        function raycasterUpdate() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cameras.flatMap(cam => cam.children), true);

            if (intersects.length > 0) {
                if (INTERSECTED !== intersects[0].object) {
                    if (INTERSECTED && INTERSECTED.material && INTERSECTED.material.emissiveIntensity !== undefined) {
                        INTERSECTED.material.emissiveIntensity = 0.1;
                    }
                    INTERSECTED = intersects[0].object;
                    if (INTERSECTED.material && INTERSECTED.material.emissiveIntensity !== undefined) {
                        INTERSECTED.material.emissiveIntensity = 0.5;
                    }
                }
            } else {
                if (INTERSECTED && INTERSECTED.material && INTERSECTED.material.emissiveIntensity !== undefined) {
                    INTERSECTED.material.emissiveIntensity = 0.1;
                }
                INTERSECTED = null;
            }
        }


        // --- Event Handlers (Updated for Mobile) ---
        function onMouseMove(event) {
            // Desktop mouse movement for look-around effect
            mouseX = event.clientX - window.innerWidth / 2;
            mouseY = event.clientY - window.innerHeight / 2;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // Update custom cursor
            const cursor = document.querySelector('.cursor');
            const follower = document.querySelector('.cursor-follower');
            
            if (cursor) cursor.style.left = event.clientX - 10 + 'px';
            if (cursor) cursor.style.top = event.clientY - 10 + 'px';
            
            if (follower) follower.style.left = event.clientX - 20 + 'px';
            if (follower) follower.style.top = event.clientY - 20 + 'px';
        }

        function onTouchStart(event) {
            // Simple click detection on touch start for interaction
            mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
        }

        let initialDistance = null;
        let initialZ = null;

        function onTouchMove(event) {
            // Pinch-to-zoom simulation (only 2 fingers for camera Z position)
            if (event.touches.length === 2) {
                // Prevent scrolling/default touch actions
                event.preventDefault(); 

                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                
                // Simplified distance check for zoom
                const distance = Math.hypot(touch1.clientX - touch2.clientX, touch1.clientY - touch2.clientY);

                // Use a simple state to track initial distance for delta calculation
                if (initialDistance === null) {
                    initialDistance = distance;
                    initialZ = camera.position.z;
                }

                const zoomDelta = distance - initialDistance;
                // Adjust sensitivity and direction
                camera.position.z = initialZ - zoomDelta * 0.05; 
                camera.position.z = Math.max(10, Math.min(50, camera.position.z));
            } else {
                initialDistance = null;
                initialZ = null;
            }
        }

        function onClick(event) {
            // Disable click interaction on mobile unless it's explicitly on the canvas
            if (isMobile && event.target.tagName !== 'CANVAS') return;
            
            // Determine if raycasting is needed
            let currentIntersects;

            if (isMobile) {
                // Mobile: Re-run raycasting on tap
                raycaster.setFromCamera(mouse, camera);
                currentIntersects = raycaster.intersectObjects(cameras.flatMap(cam => cam.children), true);
            } else {
                // Desktop: Use the last raycast result (INTERSECTED)
                raycaster.setFromCamera(mouse, camera);
                currentIntersects = raycaster.intersectObjects(cameras.flatMap(cam => cam.children), true);
            }

            if (currentIntersects.length > 0) {
                let objectToExplode = currentIntersects[0].object;
                let cameraGroup = objectToExplode.parent;
                
                if (cameraGroup) {
                    createExplosion(cameraGroup.position);
                }
            }
        }

        function onWheel(event) {
            // Desktop only scroll zoom
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(10, Math.min(50, camera.position.z));
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (event.code === 'Space') {
                // Reset camera position
                camera.position.set(0, 5, 30);
                camera.rotation.set(0, 0, 0);
            }
        }
        
        function simulateLoading() {
            let progress = 0;
            const loadingInterval = setInterval(() => {
                progress += Math.random() * 20;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        const loaderElement = document.getElementById('loader');
                        if (loaderElement) loaderElement.classList.add('hidden');
                        animate();
                        showInfoCard();
                    }, 500);
                }
                const progressBarElement = document.getElementById('progress');
                if (progressBarElement) progressBarElement.style.width = progress + '%';
            }, 200);
        }

        function showInfoCard() {
            // Only show the info card automatically on desktop
            if (isMobile) return; 

            const infoCard = document.getElementById('infoCard');
            if (!infoCard) return;

            setTimeout(() => {
                infoCard.classList.add('active');
            }, 1000);
            
            setTimeout(() => {
                infoCard.classList.remove('active');
            }, 5000);
        }

        // Initialize
        if (typeof THREE !== 'undefined' && document.getElementById('canvas')) {
            init();
        } else {
            // Log an error if THREE.js didn't load (unlikely with CDN) or canvas is missing
            console.error('THREE.js or Canvas not available.');
        }
    </script>
</body>
</html>
